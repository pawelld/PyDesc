\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{hyperref}


%opening
\title{PyDesc: tutorial}
\author{Tymoteusz Oleniecki, Pawe≈Ç Daniluk}


\lstMakeShortInline[language=Python,basicstyle=\ttfamily]~

\lstset{language=Python,basicstyle=\ttfamily}

\begin{document}

\maketitle

\section{Checkout and build}

Latest version of PyDesc is available in the Subversion repository. To check out PyDesc files one has to run following command:
\begin{lstlisting}
svn co http://trac.dw/repos/PyDesc
\end{lstlisting}

Currently all library files are stored in /PyDesc/trunk directory.
\\
To build parts of PyDesc that need compilation - see \url{http://trac.dw/trac/wiki/DevelopmentEnvironment}.

\section{Loading structures}

PyDesc allows to load a pdb file from local hard drive or to download it from on of following databases: PDB (full structures and biological units), CATH, SCOP. Downloaded files are stored locally. By default structures that are already in the cache are not downloaded again, but this setting can be changed.
To deal with PDB files module ~pydesc.structure~ should be used. To load any structure, an instance of structure loader is needed:
\begin{lstlisting}
from pydesc.structure import StructureLoader
structure_loader = StructureLoader()
\end{lstlisting}

\subsection{Loading a local file}

To load chosen file call ~load_structure~ method:
\begin{lstlisting}
list_of_structures = structure_loader.load_structure(
			'1no5', '/home/user/1no5.pdb')
\end{lstlisting}
Method returns list of loaded models. In case of X-Ray structures it contains only one object, but for NMR structures returns there are usually approx. 20 objects. 

\subsection{Downloading structures from the web}

The same method allows users to download PDB files from databases. In this case path string is not needed:
\begin{lstlisting}
list_of_structures = structure_loader.load_structure('1no5')
\end{lstlisting}
PyDesc will first search for appropriate structure in local directory ~./biodb/<db>/<code indicator>/<code>~. If file is not found - PyDesc will automatically download it. By default StructureLoader instances download files from the first database, which contains a structure with given code. There are two ways of forcing PyDesc to use a particular database. First, to give appropriate database handler as argument for structure loader used to download files:
\begin{lstlisting}
from pydesc.dbhandler import PDBHandler
structure_loader = StructureLoader(PDBHandler())
list_of_structures = structure_loader.load_structure('1no5')
\end{lstlisting}
Classes dealing with single database available in ~pydesc.dbhandler~ are listed below:
\begin{itemize}
\item SCOPHandler
\item CATHHandler
\item PDBHandler
\item BioUnitHandler -- loads biological units from PDB
\end{itemize}

Second way is to use MetaHandler, which is used by default when no handler is given for StructureLoader constructor with appropriate URL:
\begin{lstlisting} 
from pydesc.dbhandler import PDBHandler
structure_loader = StructureLoader(MetaHandler())
	# the same result as calling it without any argument
structures_1 = structure_loader.load_structure('pdb://1no5')
structures_2 = structure_loader.load_structure('cath://1no5')
structures_3 = structure_loader.load_structure('Unit://1no5')
structures_4 = structure_loader.load_structure('Unit://1no5/1')
\end{lstlisting}
Additional information for BioUnit database about index of particle to be downloaded can be passed as shown above.
\section{Working with structures}
Structures and their substructures are iterable containers for mers that support indexing and slicing. Substructures, such as Chains, Segments (continuous parts of a chain) or other, are created during calculations by PyDesc, or can be created by users:
\begin{lstlisting}
structure_loader = StructureLoader()
structure1 = structure_loader.load_structure('1no5')[0]
chain1 = structure1.chains[0]
	# instance of pydesc.structure.Chain
seg1 = structure1[5:10]
	# instance of pydesc.structure.Segment
\end{lstlisting}
Mers are indexed from 1 and their index identifies them unambiguously in structure and any substructure. Therefore the first mer of a substructure rarely has index 1. To make access easier the first mer can be accessed with index 0. Indexing with "-" sign brings subsequent mers from end of structure just like in Python lists. Also PDB ids can be used as strings. NOTE: unlike list slices, slice of structure contains mer indexed with the end index of a given range:
\begin{lstlisting}
structure1[10] in seg1  # returns True
seg1[1]  # raises IndexError
seg1_1st_mer = seg1[0]
seg2 = structure1['A23':-1]
seg3 = structure1[5:'A23']
\end{lstlisting}

Mers contain atoms and pseudoatoms - points that don't exist in the PDB file, but can be useful during calculations, like geometrical center of particle. By default, mers iterate over both, but user can also get an iterator that runs over atoms only. Both, atoms and pseudoatoms, inherit from ~pydesc.geometry.Coord~ class (vectors) which supports basic operations like subtraction and allows to calculate length or multiplying all elements by a scalar.

Atoms are stored in a dictionary in which atoms names are keys. Note that PDB distinguishes atoms names with white characters, e.g. alpha carbon (~'CA '~) and calcium ion (~'CA'~) differ by a space at the end, thus it is important to properly format strings.

\begin{lstlisting}
list(seg1[5])  # list of all atoms and pseudoatoms
list(seg1[5].iter_atoms())  # list of atoms only
distance = (seg2[-1].rc - seg3[-1].rc).calculate_length()
	# returns distance between last mer of
	# seg2 and last mer of seg3
mer1 = structure1[25]
ca_cb_vector = mer1.atoms['CB '] - mer1.atoms['CA ']
ca_cb_versor = ca_cb_vector / ca_cb_vector.calculate_length()
\end{lstlisting}


\section{Loading a DCD trajectory}

DCD trajectory can easily be loaded and linked with an already loaded structure with a ~link_dcd_file~ method:

\begin{lstlisting}
structure_loader = StructureLoader()
struct = structure_loader.load_structure('mdmd',
		 '/home/user/str.pdb')[0]
struct.link_dcd_file('/home/user/str.dcd')
\end{lstlisting}

When structure is linked with a DCD trajectory, atom coordinates change when value of a ~frame~ property changes.

\begin{lstlisting}
for step in range(1,11):
	print struct[0].atoms['CA '].get_coord()
	struct.frame = step
\end{lstlisting}

Although assigning values to ~frame~ is very handy, increasing frame by one can be achieved faster with ~next_frame~ method:

\begin{lstlisting}
for step in range(1,11):
	print struct[0].rc.get_coord()
	# prints coordinates of geometrical center
	# of first mer
	struct.next_frame()
\end{lstlisting}

In the example above we are requesting coordinates of a ~Pseudoatom~ which is not stored in DCD file. They are computed dynamically for each step, which may take time.

\section{Contact maps}

Contact map is a tool that checks if mers in structure are in contact under given criteria. In order to use them there is a need to create contact criterion instance. User can use own classes or use one of premade criteria. Settings that determines how premade criteria are evaluated are stored in configuration manager.

\begin{lstlisting}
from pydesc.contacts import CaContact
from pydesc.structure import StructureLoader
from pydesc.config import ConfigManager
ConfigManager.contacts.ca_contact_distance
ConfigManager.contacts.ca_contact_undecidable_range
	# above properties show what distance between 
	# alpha carbons is accetable to say that mers
	# are in contact (value 2) or not (0).
	# undecidable range is range that spreads around
	# border value. if distance between two mers
	# alpha carbons is in the undecidable range,
	# contact value is 1.
structure_loader = StructureLoader()
struct = structure_loader.load_structure('1no5')[0]
struct.set_contact_map(CaContact())
cv1 = struct.contact_map.get_contact_value(1, 2)
	# value of contact between 1st and 2nd mer
cv2 = struct.contact_map.get_contact_value(1, 50)
	# value of contact between 1st and 50th mer
\end{lstlisting}

~ContactCriterion~ subclasses have to implement a method called ~is_in_contact~:

\begin{lstlisting}
from pydesc.contacts import ContactCriterion
from pydesc.structure import StructureLoader
from pydesc.config import ConfigManager

class MyCriterion(ContactCriterion):
	def is_in_contact(self, mer1, mer2, lazy=False):
		try:
			at1 = mer1.atoms['CA ']
			at2 = mer2.atoms['CA ']
			dist = (at1 - at2).calculate_length()
		except KeyError:
			return 0
		if dist < 5:
			return 2
		elif 5 <= dist <= 6:
			return 1
		else:
			return 0

structure_loader = StructureLoader()
struct = structure_loader.load_structure('1no5')[0]
struct.set_contact_map(MyCriterion())
cv1 = struct.contact_map.get_contact_value(1, 2)
cv2 = struct.contact_map.get_contact_value(1, 50)
\end{lstlisting}

There is also possibility to combine simple criteria:

\begin{lstlisting}
from pydesc.contacts import ContactsAlternative
from pydesc.contacts import ContactsConjunction
from pydesc.contacts import RcContact
from pydesc.contacts import CbxContact
from pydesc.contacts import CaContact

ca_or_rc = ContactsAlternative(RcContact(), CaContact())
ca_cbx_and_rc = ContactsConjunction(RcContact(), CaContact(), CbxContact())
\end{lstlisting}

Contact maps can be calculated for structures with linked DCD trajectory. In that case all contacts will be recalculated after frame change when the value of any contact is requested for the first time.

\end{document}
