# PyDesc cookbook## ConfigurationGeneral configuration description to be added.<!--==== TEMPLATE## TemplateDescription### ConfigurationThere is no related configuration.### API### Simple usage### There is more ==== TEMPLATE END-->## Loading structuresBasis for any study one can perform using PyDesc is loading structure.### ConfigurationThere is no related configuration.### APIAPI description to be added.### Simple usageTo quickly load structure and be able to read and edit it, simply run:```pythonfrom pydesc.structure import StructureLoaderstructure_loader = StructureLoader()models_list = structure_loader.load_structures('1no5')structure = models_list[0]  # if there is more than one model in pdb file                            # they are stored in resulting listfor mer in structure:    print(mer)          # residues, nucleotides or others (ions or ligands)    for atom in mer.atoms:        print(atom)    for pseudoatom in mer.pseudoatoms:        print(pseudoatom)```### There is moreTo gain more control over process of loading structure, note that there are detailsthat could be changed. Lets take a look on the example (explained below):```pythonfrom pydesc import dbhandlerfrom pydesc.mers import factories as mer_factoriesfrom pydesc.structure import StructureLoaderdb_handler = dbhandler.MetaHandler(mode=(3, 2, 1))file_parser = dbhandler.MetaParser(QUIET=True)mer_factory = mer_factories.BioPythonMerFactory()structure_loader = StructureLoader(    handler=db_handler,    parser=file_parser,    mer_factory=mer_factory,    )models_db = structure_loader.load_structures(code="1no5")  # download from dbmodels_hd = structure_loader.load_structures(path='tests/data/dbtest/PDB/1nkl')                                                           # download from hard drive````db_handler = dbhandler.MetaHandler(mode=(3, 2, 1))`Handlers are objects responsible for handling structure files.There is at least one for each data base.Meta handler contains them all.Learn more [here](#structure-file-handlers).`file_parser = dbhandler.MetaParser()`Pydesc uses external file parsers, e.g. from BioPython and MDTraj.MetaParser consists of PDBParser and mmCIFParser and executes both on given input.Learn more [here](#file-parsers)`mer_factory = mer_factories.BioPythonMerFactory()`Mer factory is object responsible for creation of structures building blocks.Its settings are important whenever one needs to change way of how and which mers are created.Learn more [here](#mers). `models_db = structure_loader.load_structures(code="1no5")`That line loads structure using file handler.Argument `code` is passed to handler, so it can be any string comprehensive for such  object, e.g. "cath://1no5" for MetaHandler or "bio://1no5/1" for BioUnitHandler.Learn more [here](#structure-file-handlers).`models_hd = structure_loader.load_structures(path='tests/data/dbtest/PDB/1nkl')`This command loads file form hard drive. Handler is surpassed, file content is given directly to parser.#### Structure file handlersHandlers are objects responsible for handling structure files.There is at least one for each data base.Meta handler contains them all.Handlers store downloaded files in local cache.Therefor users can set their behaviour by setting modes and their priorities:* in mode 3 handler reads local cache* in mode 2 handler copies file from local db to local cache (overwrite)* in mode 1 handler downloads file from remote db to local cache (overwrite)Handler tries to get files in different modes #### File parsersPyDesc does not provide any structure file parser itself.Instead it uses BioPython parsers to read `.pdb` and `.cif` files and MDTraj parsersto read different trajectories.`StructureLoader` can accept:* BioPython's PDBParser* BioPython's MMCIFParser* PyDesc's MetaParser* any object with method and signature such as: `get_structure(code: str, file_path: str)`### Mers### Substructures### Descriptors### Number converters## TrajectoriesPyDesc copes with trajectories using MDTraj library.Trajectories supposed to be dynamic version of structures, so it should be possible to do with them whatever is possible with structures.### ConfigurationThere is no related configuration.### APITo make it easier to deal with trajectories, API enables some useful functions. Below is an example usage of `api.trajectory.freeze_frame` and `api.trajectory.from_frames`.```pythonfrom pydesc import apifrom pydesc.api import trajectory from pydesc.structure import StructureLoaderfrom pydesc.structure import TrajectoryLoaderstructure_loader = StructureLoader()trajectory_loader = TrajectoryLoader()topology_path = 'tests/data/test_trajectories/topologies/mdm2.pdb'topology = structure_loader.load_structures(path=topology_path)[0]  # note [0]trajectory_path = 'tests/data/test_trajectories/xtc/mdm2_5frames.xtc'dynamic_structure = trajectory_loader.load_trajectory(trajectory_path, topology)frames = []for i in range(5):    dynamic_structure.set_frame(i)    frame = api.trajectory.freeze_frame(dynamic_structure)  # convert frame into structure    frames.append(frame)new_trajectory = api.trajectory.from_frames(frames)         # convert frames to trajectory````api.trajectory.freeze_frames` turns current frame into static structure. Frozen frames no longer change coords when `set_frame` is called.`api.trajectory.from_frames` turns list of static structures (of the same structure) into a trajectory, so it is a reverse operation. It is meant to deal with NMR structures and trajectories stored in pdb files.### Simple usageBasically, to work with trajectory, one needs topology and trajectory file.Topology is to be loaded with `StructureLoader`, trajectory -- with `TrajectoryLoader`, both coming from `structure` submodule.```pythonfrom pydesc.structure import StructureLoaderfrom pydesc.structure import TrajectoryLoaderstructure_loader = StructureLoader()trajectory_loader = TrajectoryLoader()topology_path = 'tests/data/test_trajectories/topologies/mdm2.pdb'topology = structure_loader.load_structures(path=topology_path)[0]  # note [0]trajectory_path = 'tests/data/test_trajectories/xtc/mdm2_5frames.xtc'trajectory = trajectory_loader.load_trajectory(trajectory_path, topology)last_frame = trajectory.get_n_frames()  # 5 in this caseresidue0 = trajectory[0]            # GLUsegment = trajectory[20:30]         # LYS20-PHE30position1 = residue0.ca.vector      # for residue in segment:    print(residue.ca.vector)trajectory.set_frame(3)current_frame = trajectory.get_frame()position2 = residue0.ca.vector      # all values shiftedfor residue in segment:             # as frame shifted    print(residue.ca.vector)```Trajectory loader takes two arguments: path to trajectory file and structure object returned by structure loader.Trajectory object has all the features structure has, plus methods `set_frame`, `get_frame` and `get_n_frames`.From trajectory one can derive all substructures available in PyDesc like segments or contacts, even descriptors to see how they change with time (although the same set  of residues in different frames might not be able to form descriptor any more). It is important to understand that changing trajectory frame will make implicit  changes to derivatives as well.To avoid that, it is possible to freeze frame. See how in `API` section.## Selections## Contact mapsContact maps stores data about mers in contact.Each pair of mers therefore have certain contact value, depending on definition of contact.Therefor contact map is a matrix of contacts values associated with one structure and contact criterion.### Contact CriteriaIn PyDesc contact criteria use three-value logic with possible values being:* 0 -- no contact* 1 -- possible contact* 2 -- sure contactIf it does not make sense to have uncertain value for criterion of usage -- value of 1 is dropped.TODO: finish### ConfigurationThere is no related configuration.### API### Simple usageBasic usage of contact maps uses default PyDesc criterion.```pythonfrom io import StringIOfrom pydesc.structure import StructureLoaderfrom pydesc.contacts import ContactMapCalculatorstructure_loader = StructureLoader()models_list = structure_loader.load_structures('1no5')structure = models_list[0]cm_calculator = ContactMapCalculator(structure)contact_map = cm_calculator.calculate_contact_map()file_like = StringIO()with file_like as file_h:    contact_map.to_string(file_h)for mer_ids, contact_value in contact_map:    mer1, mer2 = mer_ids        if contact_value == 0:        value_string = " not"    elif contact_value == 1:        value_string = " probably"    else:        value_string = " "    print(f"Residue {mer1} and {mer2} are{value_string} in contact.")cv_12_34 = contact_map.get_contact_value(12, 34)m12_contacts = contact_map.get_mer_contacts(12)````cm_calculator = ContactMapCalculator(structure)` prepares contact map calculation for given structure with default contact criterion.`contact_map = cm_calculator.calculate_contact_map()` performs calculation and returns ContactMap instance. This object stores calculated data.`file_like = StringIO()` creates stream that mimics file handler. Along with `with file_like as file_h: contact_map.to_string(file_h)` it could be replaced with `with open(<path>) as fh: contact_map.to_string(fh)` in order to save results to file.`for mer_ids, contact_value in contact_map: ...` utilises fact that contact maps are iterable. Iterator returns tuples storing two elements: mer ids and contact value. Mer ids is nested tuple with two integers. Contact value is integer 1 or 2. Contacts of value 0 are skipped by iterator.`cv_12_34 = contact_map.get_contact_value(12, 34)` Returns value of contact between two mers. When having access to mer objects -- their ids are stored as `ind` attribute, so:<!--excluded from tests -- that requires space at the beginning of the line.---> ```pythonmer1 = structure[12]mer2 = structure[34]cv_12_34 = contact_map.get_contact_value(mer1.ind, mer2.ind) ````m12_contacts = contact_map.get_mer_contacts(12)` returns list ids of mers having contact value of 1 or 2 with mer of given id.### There is more <!---zmiana kryterium-mapy dla podstruktur-dodawanie map (też tych dla podstruktur)-->## Structure comparison### Overfit### Compdesc### FitDesc## Alignments## Integration with PyMOLPyDesc was meant to be used in scripts and programs, but it can also help in EDA. Sometimes opportunity to take a look at structures we work with can greatly help in understanding the problem, whether it is development of some tool or research.Knowing this we introduced some functions that utilise broadly used visualisation software for biomolecules -- PyMOL. Integration is not full, there is no PyMOL plugin associated with PyDesc, rather bunch of useful scripts. Reason for that being our understanding of how PyDesc could be used, which is: as scripts, probably run on  clusters without graphical environment. Keeping that in mind we imagine that reason why one would need to run PyDesc with PyMOL is either to take a look at structures or  contact maps in the middle of some kind of script or at the very end of research, to  visualise results. Either way -- not using PyMOL to perform any heavy computation.Basic functionality covered by provided functions covers:* structure visualisation* contact map visualisation* creating selection representing different PyDesc objects* (future) trajectory visualisation* (future) visualisation of PyDesc alignments as superposition:    * of structures    * of descriptors### Integrating PyMOL with PyDescPyMOL uses its ovn copy od Python, so just having PyDesc installed in Python is not enough.There are two ways of integrating PyMOL with PyDesc:1. install PyDesc in PyMOL's copy of Python1. build PyMOL from source and include installed PyDesc library#### Install PyDescNot covered yet.#### Build own PyMOL from source1. clone repo `git clone https://github.com/schrodinger/pymol-open-source/blob/master`1. `cd pymol-open-source`1. install all pre-requirements1. run `PREFIX_PATH=<site-packages> python setup.py install --prefix=<install-dir>`, where `<site-packages>` is path to `site-packages` dir with PyDesc installed of your local Python 3.6+ and `<install-dir>` is directory to install pymol to.1. to run pymol execute `<install-dir>/bin/pymol`Trick for `freetype`, which sometimes is not recognised by C++ compiler:- locate you freetype directory (`<freetype-dir>`)- set variable `CPATH=<freetype-dir>` in the same line where `python setup.py` is called### ConfigurationThere is no related configuration.### APIAll functions related to PyMOL are provided in `api` module.This module requires PyMOL to be installed, otherwise it is impossible (well, very hard) to import it.It provides subsequent functions:* draw_structures* draw_contact* draw_contact_maps* select#### Visualising structures<!--excluded from tests -- that requires space at the beginning of the line.---> ```pythonfrom pydesc.api.pymol import draw_structuresfrom pydesc.structure import StructureLoaderloader = StructureLoader()structures = loader.load_structures("2ljp") # 20 NMR structuredraw_structures(structures) ```For more detailed description of structure loading look [here](#loading-structures).Line `draw_structures(structures)` creates single object in PyMOL and puts 20 structures loaded by PyDesc as separate states of that object.Every structure that we want to visualise in PyMOL is added to registry with its PyMOL  object name and state. Changing any of it in PyMOL will have unpredicted consequences. `draw_structures(structures, split_states=True)` would load them as 20 separate objects.Note that is order to load single structure one still needs to pass list (with single  item) as first argument.#### Visualising contact mapsTo see how to draw contact maps consider following code:<!--excluded from tests -- that requires space at the beginning of the line.---> ```pythonfrom pydesc.api.pymol import draw_structuresfrom pydesc.api.pymol import draw_contact_mapsfrom pydesc.structure import StructureLoaderfrom pydesc.contacts import ContactMapCalculatorloader = StructureLoader()structures = loader.load_structures("2ljp") # 20 NMR structuresdraw_structures(structures)contact_maps = []for structure in structures:    cm_calculator = ContactMapCalculator(structure)    contact_map = cm_calculator.calculate_contact_map()    contact_maps.append(contact_map)draw_contact_maps(contact_maps) ```Note that `draw_structures(structures)` line is required in order to have contact maps drawn. To learn more about this function read [this](#visualising-structures).For description of contact map calculation look [here](#contact-maps).Line `draw_contact_maps(contact_maps)` will add two contact maps: red one showing all  certain (according to given contact criterion) contacts (contact value 2); and orange  one for uncertain contacts (contact value 1). Since maps were calculated for structures stored in different states of single PyMOL  object -- to see then one needs to change visualised state (in PyMOL press ">" and "<" in right bottom panel to change states).If structures were loaded with `split_states` argument set to `True`, `draw_contact_maps` would simply draw two separate maps for each structure.Note that to draw single contact map one still needs to pass single-item list as first argument.Function `draw_contact_maps` takes two optional arguments:* `split_contacts` -- by default set to False, otherwise it creates different object  for each contact in contact map rather than storing all contacts as two contact maps.* `point` -- name of atom or pseudoatom to be pointed at by two ends of dashed line  representing contact. By default it is `rc`, which is geometrical center of mer (or  its side chain). Function will skip contacts for mers that lack chosen (pseudo)atom  (`rc` is always present). That option makes sense only for contact maps for very  specific cases, e.g. for nucleic acids it makes sense to chang it to (`ring_center`).Additionally it is possible to draw single contacts with `draw_contact` function. It  takes three positional arguments: * structure or substructure * two mer indicatorsFor example, below previous example one could add: ```pythondraw_contact(structure[0], 12, 34)segment = structure[0][12:34]draw_contact(segment, 13, 33) ```to add single contacts, even though they are not present in contact maps.Similarly to `draw_contact_maps`, `draw_contact` takes optional arguments: * `point` -- doing the same for both functions. * `contact_name` -- to change default name to the one passed as this argument. * `gap` -- float, length of gap between dashes of drawn line.#### Selecting PyDesc substructures in PyMOLTerm "selection" means something different in PyDesc and in PyMOL.Different types of substructures, e.g. descriptors, that one can create in PyDesc can  be turned into selections in PyMOL, if their parent structure was already drawn. To do so, one needs function `select`, which takes two arguments: * (sub)structure (PyDesc object), e.g. segment or descriptor. * name of selection to be created (its optional, by default name "sele" is passed).Selections can be later visualised in different ways.Note that PyMOL selections have no sense of object states, which might cause some  unexpected behaviour for structures loaded as different states.## END