# PyDesc cookbook## ConfigurationGeneral configuration description to be added.<!--==== TEMPLATE## TemplateDescription### ConfigurationThere is no related configuration.### API### Simple usage### There is more ==== TEMPLATE END-->## Loading structuresBasis for any study one can perform using PyDesc is loading structure.### ConfigurationThere is no related configuration.### APIAPI description to be added.### Simple usageTo quickly load structure and be able to read and edit it, simply run:```pythonfrom pydesc.structure import StructureLoaderstructure_loader = StructureLoader()models_list = structure_loader.load_structures('1no5')structure = models_list[0]  # if there is more than one model in pdb file                            # they are stored in resulting listfor mer in structure:    print(mer)          # residues, nucleotides or others (ions or ligands)    for atom in mer.atoms:        print(atom)    for pseudoatom in mer.pseudoatoms:        print(pseudoatom)```### There is moreTo gain more control over process of loading structure, note that there are detailsthat could be changed. Lets take a look on the example (explained below):```pythonfrom pydesc import dbhandlerfrom pydesc.mers import factories as mer_factoriesfrom pydesc.structure import StructureLoaderdb_handler = dbhandler.MetaHandler(mode=(3, 2, 1))file_parser = dbhandler.MetaParser(QUIET=True)mer_factory = mer_factories.BioPythonMerFactory()structure_loader = StructureLoader(    handler=db_handler,    parser=file_parser,    mer_factory=mer_factory,    )models_db = structure_loader.load_structures(code="1no5")  # download from dbmodels_hd = structure_loader.load_structures(path='tests/data/dbtest/PDB/1nkl')                                                           # download from hard drive````db_handler = dbhandler.MetaHandler(mode=(3, 2, 1))`Handlers are objects responsible for handling structure files.There is at least one for each data base.Meta handler contains them all.Learn more [here](#structure-file-handlers).`file_parser = dbhandler.MetaParser()`Pydesc uses external file parsers, e.g. from BioPython and MDTraj.MetaParser consists of PDBParser and mmCIFParser and executes both on given input.Learn more [here](#file-parsers)`mer_factory = mer_factories.BioPythonMerFactory()`Mer factory is object responsible for creation of structures building blocks.Its settings are important whenever one needs to change way of how and which mers are created.Learn more [here](#mers). `models_db = structure_loader.load_structures(code="1no5")`That line loads structure using file handler.Argument `code` is passed to handler, so it can be any string comprehensive for such  object, e.g. "cath://1no5" for MetaHandler or "bio://1no5/1" for BioUnitHandler.Learn more [here](#structure-file-handlers).`models_hd = structure_loader.load_structures(path='tests/data/dbtest/PDB/1nkl')`This command loads file form hard drive. Handler is surpassed, file content is given directly to parser.#### Structure file handlersHandlers are objects responsible for handling structure files.There is at least one for each data base.Meta handler contains them all.Handlers store downloaded files in local cache.Therefor users can set their behaviour by setting modes and their priorities:* in mode 3 handler reads local cache* in mode 2 handler copies file from local db to local cache (overwrite)* in mode 1 handler downloads file from remote db to local cache (overwrite)Handler tries to get files in different modes #### File parsersPyDesc does not provide any structure file parser itself.Instead it uses BioPython parsers to read `.pdb` and `.cif` files and MDTraj parsersto read different trajectories.`StructureLoader` can accept:* BioPython's PDBParser* BioPython's MMCIFParser* PyDesc's MetaParser* any object with method and signature such as: `get_structure(code: str, file_path: str)`### Mers### Substructures### Descriptors### Number converters## TrajectoriesPyDesc copes with trajectories using MDTraj library.Trajectories supposed to be dynamic version of structures, so it should be possible to do with them whatever is possible with structures.### ConfigurationThere is no related configuration.### APITo make it easier to deal with trajectories, API enables some useful functions. Below is an example usage of `api.trajectory.freeze_frame` and `api.trajectory.from_frames`.```pythonfrom pydesc import apifrom pydesc.api import trajectory from pydesc.structure import StructureLoaderfrom pydesc.structure import TrajectoryLoaderstructure_loader = StructureLoader()trajectory_loader = TrajectoryLoader()topology_path = 'tests/data/test_trajectories/topologies/mdm2.pdb'topology = structure_loader.load_structures(path=topology_path)[0]  # note [0]trajectory_path = 'tests/data/test_trajectories/xtc/mdm2_5frames.xtc'dynamic_structure = trajectory_loader.load_trajectory(trajectory_path, topology)frames = []for i in range(5):    dynamic_structure.set_frame(i)    frame = api.trajectory.freeze_frame(dynamic_structure)  # convert frame into structure    frames.append(frame)new_trajectory = api.trajectory.from_frames(frames)         # convert frames to trajectory````api.trajectory.freeze_frames` turns current frame into static structure. Frozen frames no longer change coords when `set_frame` is called.`api.trajectory.from_frames` turns list of static structures (of the same structure) into a trajectory, so it is a reverse operation. It is meant to deal with NMR structures and trajectories stored in pdb files.### Simple usageBasically, to work with trajectory, one needs topology and trajectory file.Topology is to be loaded with `StructureLoader`, trajectory -- with `TrajectoryLoader`, both coming from `structure` submodule.```pythonfrom pydesc.structure import StructureLoaderfrom pydesc.structure import TrajectoryLoaderstructure_loader = StructureLoader()trajectory_loader = TrajectoryLoader()topology_path = 'tests/data/test_trajectories/topologies/mdm2.pdb'topology = structure_loader.load_structures(path=topology_path)[0]  # note [0]trajectory_path = 'tests/data/test_trajectories/xtc/mdm2_5frames.xtc'trajectory = trajectory_loader.load_trajectory(trajectory_path, topology)last_frame = trajectory.get_n_frames()  # 5 in this caseresidue0 = trajectory[0]            # GLUsegment = trajectory[20:30]         # LYS20-PHE30position1 = residue0.ca.vector      # for residue in segment:    print(residue.ca.vector)trajectory.set_frame(3)current_frame = trajectory.get_frame()position2 = residue0.ca.vector      # all values shiftedfor residue in segment:             # as frame shifted    print(residue.ca.vector)```Trajectory loader takes two arguments: path to trajectory file and structure object returned by structure loader.Trajectory object has all the features structure has, plus methods `set_frame`, `get_frame` and `get_n_frames`.From trajectory one can derive all substructures available in PyDesc like segments or contacts, even descriptors to see how they change with time (although the same set  of residues in different frames might not be able to form descriptor any more). It is important to understand that changing trajectory frame will make implicit  changes to derivatives as well.To avoid that, it is possible to freeze frame. See how in `API` section.## Selections## Contact mapsContact maps stores data about mers in contact.Each pair of mers therefore have certain contact value, depending on definition of contact.Therefor contact map is a matrix of contacts values associated with one structure and contact criterion.### Contact CriteriaIn PyDesc contact criteria use three-value logic with possible values being:* 0 -- no contact* 1 -- possible contact* 2 -- sure contactIf it does not make sense to have uncertain value for criterion of usage -- value of 1 is dropped.TODO: finish### ConfigurationThere is no related configuration.### API### Simple usageBasic usage of contact maps uses default PyDesc criterion.```pythonfrom io import StringIOfrom pydesc.structure import StructureLoaderfrom pydesc.contacts import ContactMapCalculatorstructure_loader = StructureLoader()models_list = structure_loader.load_structures('1no5')structure = models_list[0]cm_calculator = ContactMapCalculator(structure)contact_map = cm_calculator.calculate_contact_map()file_like = StringIO()with file_like as file_h:    contact_map.to_string(file_h)for mer_ids, contact_value in contact_map:    mer1, mer2 = mer_ids        if contact_value == 0:        value_string = " not"    elif contact_value == 1:        value_string = " probably"    else:        value_string = " "    print(f"Residue {mer1} and {mer2} are{value_string} in contact.")cv_12_34 = contact_map.get_contact_value(12, 34)m12_contacts = contact_map.get_mer_contacts(12)````cm_calculator = ContactMapCalculator(structure)` prepares contact map calculation for given structure with default contact criterion.`contact_map = cm_calculator.calculate_contact_map()` performs calculation and returns ContactMap instance. This object stores calculated data.`file_like = StringIO()` creates stream that mimics file handler. Along with `with file_like as file_h: contact_map.to_string(file_h)` it could be replaced with `with open(<path>) as fh: contact_map.to_string(fh)` in order to save results to file.`for mer_ids, contact_value in contact_map: ...` utilises fact that contact maps are iterable. Iterator returns tuples storing two elements: mer ids and contact value. Mer ids is nested tuple with two integers. Contact value is integer 1 or 2. Contacts of value 0 are skipped by iterator.`cv_12_34 = contact_map.get_contact_value(12, 34)` Returns value of contact between two mers. When having access to mer objects -- their ids are stored as `ind` attribute, so: ```pythonmer1 = structure[12]mer2 = structure[34]cv_12_34 = contact_map.get_contact_value(mer1.ind, mer2.ind) ````m12_contacts = contact_map.get_mer_contacts(12)` returns list ids of mers having contact value of 1 or 2 with mer of given id.### There is more <!---zmiana kryterium-mapy dla podstruktur-dodawanie map (też tych dla podstruktur)-->## Structure comparison### Overfit### Compdesc### FitDesc## Alignments## DescMOL